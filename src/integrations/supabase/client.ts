
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { SushiCategory } from '@/types';

const SUPABASE_URL = "https://tdykegnmomyyucbhslok.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRkeWtlZ25tb215eXVjYmhzbG9rIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI3NjA2NjUsImV4cCI6MjA1ODMzNjY2NX0.88jbkZIkFiFXudHvqe0l2DhqQGh2V9JIThv9FFFagas";

// Configuration spécifique pour forcer l'utilisation de WebSocket sécurisé
const REALTIME_URL = "wss://tdykegnmomyyucbhslok.supabase.co/realtime/v1";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  realtime: {
    params: {
      eventsPerSecond: 10,
    }
  }
});

export const fetchOrderWithDetails = async (orderId: string) => {
  if (!orderId) {
    console.error("No order ID provided");
    return null;
  }
  
  try {
    // Fetch order with basic details including items_summary
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .select('*')
      .eq('id', orderId)
      .single();
      
    if (orderError) throw orderError;
    
    // Process items_summary to group duplicates by name, OR fallback to order_items for old orders
    let processedItems = [];
    // Check if items_summary has actual content, if not fallback to order_items
    const hasValidItemsSummary = (order as any).items_summary && 
      Array.isArray((order as any).items_summary) && 
      (order as any).items_summary.length > 0;
    
    if (hasValidItemsSummary) {
      // NEW: Use items_summary (from webhook)
      const itemsMap = new Map();
      
      // Group items by name and sum quantities
      (order as any).items_summary.forEach((item: any) => {
        const name = item.name;
        if (itemsMap.has(name)) {
          const existing = itemsMap.get(name);
          existing.quantity += (item.quantity || 1);
          // Keep the highest price if different
          if (item.price && item.price > existing.price) {
            existing.price = item.price;
          }
        } else {
          itemsMap.set(name, {
            id: item.id,
            name: item.name,
            price: item.price || 0,
            quantity: item.quantity || 1
          });
        }
      });
      
      processedItems = Array.from(itemsMap.values());
    } else {
      // FALLBACK: Use order_items table for old orders
      const { data: orderItems, error: itemsError } = await supabase
        .from('order_items')
        .select('*, products(*)')
        .eq('order_id', orderId);
        
      if (!itemsError && orderItems) {
        // Convert order_items to same format as items_summary
        const itemsMap = new Map();
        
        orderItems.forEach((item: any) => {
          const name = item.products?.name || `Produit ${item.product_id?.substring(0, 8)}`;
          if (itemsMap.has(name)) {
            const existing = itemsMap.get(name);
            existing.quantity += (item.quantity || 1);
          } else {
            itemsMap.set(name, {
              id: item.id,
              name: name,
              price: item.price || 0,
              quantity: item.quantity || 1,
              special_instructions: item.special_instructions
            });
          }
        });
        
        processedItems = Array.from(itemsMap.values());
      }
    }
    
    // Fetch customer profile details
    let customerDetails = null;
    if ((order as any).user_id) {
      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', (order as any).user_id)
        .single();
        
      if (!profileError) {
        customerDetails = profile;
      }
    }
    
    // Fetch delivery address if available
    let addressDetails = null;
    if ((order as any).delivery_address_id) {
      const { data: address, error: addressError } = await supabase
        .from('user_addresses')
        .select('*')
        .eq('id', (order as any).delivery_address_id)
        .single();
        
      if (!addressError) {
        addressDetails = address;
      }
    }
    
    // Return complete order details with processed items from items_summary
    return {
      ...(order as any),
      order_items: processedItems, // Now using processed items_summary instead of order_items table
      customer: customerDetails,
      delivery_address: addressDetails
    };
    
  } catch (error) {
    console.error("Error fetching order details:", error);
    return null;
  }
};

// Helper function to fetch all products and categories in a single request
export const fetchAllMenuData = async (restaurantId?: string) => {
  console.log("Fetching all menu data for restaurant:", restaurantId);
  
  try {
    // Utiliser Châteaurenard par défaut si pas de restaurant spécifié
    const targetRestaurantId = restaurantId || '11111111-1111-1111-1111-111111111111';
    
    // Fetch categories for this restaurant
    const { data: categories, error: categoriesError } = await supabase
      .from('categories')
      .select('*')
      .eq('restaurant_id', targetRestaurantId)
      .order('display_order', { ascending: true });
    
    if (categoriesError) {
      console.error("Error fetching categories:", categoriesError);
      return [];
    }
    
    // Fetch products for this restaurant
    const { data: products, error: productsError } = await supabase
      .from('products')
      .select('*')
      .eq('restaurant_id', targetRestaurantId)
      .eq('is_hidden', false)
      .order('price', { ascending: true });
    
    if (productsError) {
      console.error("Error fetching all products:", productsError);
      return [];
    }
    
    // Group products by category
    const menuData = categories.map(category => {
      const categoryProducts = products.filter((product: any) => product.category_id === (category as any).id);
      
      // Transform products to menu items
      const menuItems = categoryProducts.map((product: any) => ({
        id: product.id,
        name: product.name,
        description: product.description,
        price: product.price,
        imageUrl: product.image_url || "/placeholder.svg",
        category: product.category_id as SushiCategory,
        isVegetarian: product.is_vegetarian || false,
        isSpicy: product.is_spicy || false,
        isNew: product.is_new || false,
        isBestSeller: product.is_best_seller || false,
        allergens: product.allergens,
        pieces: product.pieces
      }));
      
      return {
        id: (category as any).id as SushiCategory,
        name: (category as any).name,
        description: (category as any).description,
        items: menuItems
      };
    });
    
    console.log(`Loaded ${categories.length} categories and ${products.length} total products for restaurant ${targetRestaurantId}`);
    return menuData;
  } catch (error) {
    console.error("Error fetching all menu data:", error);
    return [];
  }
};

// Helper function to fetch products by category for a specific restaurant
export const fetchProductsByCategory = async (categoryId: string, restaurantId?: string) => {
  const targetRestaurantId = restaurantId || '11111111-1111-1111-1111-111111111111';
  console.log(`Fetching products for category: ${categoryId} in restaurant: ${targetRestaurantId}`);
  
  const { data, error } = await supabase
    .from('products')
    .select('*')
    .eq('category_id', categoryId)
    .eq('restaurant_id', targetRestaurantId)
    .eq('is_hidden', false)
    .order('price', { ascending: true });
  
  if (error) {
    console.error("Error fetching products:", error);
    return [];
  }
  
  console.log(`Found ${data?.length || 0} products for category ${categoryId} in restaurant ${targetRestaurantId}`);
  return data || [];
};

// Helper function to fetch categories for a specific restaurant
export const fetchCategories = async (restaurantId?: string) => {
  const targetRestaurantId = restaurantId || '11111111-1111-1111-1111-111111111111';
  console.log("Fetching categories for restaurant:", targetRestaurantId);
  
  const { data, error } = await supabase
    .from('categories')
    .select('*')
    .eq('restaurant_id', targetRestaurantId)
    .order('display_order', { ascending: true });
  
  if (error) {
    console.error("Error fetching categories:", error);
    return [];
  }
  
  console.log(`Found ${data?.length || 0} categories for restaurant ${targetRestaurantId}`);
  return data || [];
};

// Helper function to fetch all products for a specific restaurant
export const fetchAllProducts = async (restaurantId?: string) => {
  const targetRestaurantId = restaurantId || '11111111-1111-1111-1111-111111111111';
  console.log("Fetching all products for restaurant:", targetRestaurantId);
  
  const { data, error } = await supabase
    .from('products')
    .select('*, categories(name)')
    .eq('restaurant_id', targetRestaurantId)
    .order('price', { ascending: true });
  
  if (error) {
    console.error("Error fetching products:", error);
    return [];
  }
  
  console.log(`Found ${data?.length || 0} total products for restaurant ${targetRestaurantId}`);
  return data || [];
};

// Helper function to insert a new category
export const insertCategory = async (category: {
  id: string;
  name: string;
  description?: string | null;
  display_order: number;
  restaurant_id: string;
}) => {
  console.log(`Inserting category: ${category.name} for restaurant: ${category.restaurant_id}`);
  const { data, error } = await supabase
    .from('categories')
    .insert(category)
    .select('*')
    .single();
    
  if (error) {
    console.error("Error inserting category:", error);
    throw error;
  }
  
  console.log(`Successfully inserted category: ${category.name}`);
  return data;
};

// Helper function to insert a new product
export const insertProduct = async (product: {
  name: string;
  description?: string | null;
  price: number;
  category_id: string;
  restaurant_id: string;
  image_url?: string | null;
  is_vegetarian?: boolean | null;
  is_spicy?: boolean | null;
  is_new?: boolean | null;
  is_best_seller?: boolean | null;
  allergens?: string[] | null;
  pieces?: number | null;
}) => {
  console.log(`Inserting product: ${product.name} in category ${product.category_id} for restaurant ${product.restaurant_id}`);
  const { data, error } = await supabase
    .from('products')
    .insert(product)
    .select('*')
    .single();
    
  if (error) {
    console.error("Error inserting product:", error.message);
    console.error("Product details:", product);
    throw error;
  }
  
  console.log(`Successfully inserted product: ${product.name}`);
  return data;
};

// Helper function to check if a product with the same name exists in a category
export const productExistsInCategory = async (name: string, categoryId: string, restaurantId?: string) => {
  const targetRestaurantId = restaurantId || '11111111-1111-1111-1111-111111111111';
  console.log(`Checking if product ${name} exists in category ${categoryId} for restaurant ${targetRestaurantId}`);
  const { data, error } = await supabase
    .from('products')
    .select('id')
    .eq('name', name)
    .eq('category_id', categoryId)
    .eq('restaurant_id', targetRestaurantId);
  
  if (error) {
    console.error("Error checking product existence:", error);
    return false;
  }
  
  const exists = data && data.length > 0;
  console.log(`Product ${name} in category ${categoryId} for restaurant ${targetRestaurantId} exists: ${exists}`);
  return exists;
};

// Helper function to update a product
export const updateProduct = async (productId: string, productData: any, restaurantId?: string) => {
  const targetRestaurantId = restaurantId || '11111111-1111-1111-1111-111111111111';
  console.log(`Updating product with ID: ${productId} for restaurant: ${targetRestaurantId}`);
  const { data, error } = await supabase
    .from('products')
    .update(productData)
    .eq('id', productId)
    .eq('restaurant_id', targetRestaurantId)
    .select('*')
    .single();
    
  if (error) {
    console.error("Error updating product:", error);
    throw error;
  }
  
  console.log(`Successfully updated product: ${productData.name}`);
  return data;
};

// Helper function to delete a product
export const deleteProduct = async (productId: string, restaurantId?: string) => {
  const targetRestaurantId = restaurantId || '11111111-1111-1111-1111-111111111111';
  console.log(`Deleting product with ID: ${productId} for restaurant: ${targetRestaurantId}`);
  try {
    // Simple delete operation without trying to count in RETURNING
    const { error } = await supabase
      .from('products')
      .delete()
      .eq('id', productId)
      .eq('restaurant_id', targetRestaurantId);
      
    if (error) {
      console.error("Error deleting product:", error);
      throw error;
    }
    
    console.log(`Successfully deleted product with ID: ${productId}`);
    return true;
  } catch (error) {
    console.error("Error in deleteProduct function:", error);
    return false;
  }
};

// Helper function to update a category
export const updateCategory = async (categoryId: string, categoryData: any, restaurantId?: string) => {
  const targetRestaurantId = restaurantId || '11111111-1111-1111-1111-111111111111';
  console.log(`Updating category with ID: ${categoryId} for restaurant: ${targetRestaurantId}`);
  const { data, error } = await supabase
    .from('categories')
    .update(categoryData)
    .eq('id', categoryId)
    .eq('restaurant_id', targetRestaurantId)
    .select('*')
    .single();
    
  if (error) {
    console.error("Error updating category:", error);
    throw error;
  }
  
  console.log(`Successfully updated category: ${categoryData.name}`);
  return data;
};

// Helper function to delete a category
export const deleteCategory = async (categoryId: string, restaurantId?: string) => {
  const targetRestaurantId = restaurantId || '11111111-1111-1111-1111-111111111111';
  console.log(`Deleting category with ID: ${categoryId} for restaurant: ${targetRestaurantId}`);
  const { error } = await supabase
    .from('categories')
    .delete()
    .eq('id', categoryId)
    .eq('restaurant_id', targetRestaurantId);
    
  if (error) {
    console.error("Error deleting category:", error);
    throw error;
  }
  
  console.log(`Successfully deleted category with ID: ${categoryId}`);
  return true;
};

// Helper function to reorder categories
export const reorderCategories = async (categories: { id: string, display_order: number }[], restaurantId?: string) => {
  const targetRestaurantId = restaurantId || '11111111-1111-1111-1111-111111111111';
  console.log(`Reordering ${categories.length} categories for restaurant: ${targetRestaurantId}`);
  
  // Create a custom transaction function for updating multiple rows
  const updates = categories.map(cat => {
    return supabase
      .from('categories')
      .update({ display_order: cat.display_order })
      .eq('id', cat.id)
      .eq('restaurant_id', targetRestaurantId);
  });
  
  try {
    // Execute all updates in parallel
    await Promise.all(updates);
    console.log("Successfully reordered categories");
    return true;
  } catch (error) {
    console.error("Error reordering categories:", error);
    throw error;
  }
};
