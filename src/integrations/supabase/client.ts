// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { SushiCategory } from '@/types';

const SUPABASE_URL = "https://tdykegnmomyyucbhslok.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRkeWtlZ25tb215eXVjYmhzbG9rIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI3NjA2NjUsImV4cCI6MjA1ODMzNjY2NX0.88jbkZIkFiFXudHvqe0l2DhqQGh2V9JIThv9FFFagas";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

export const fetchOrderWithDetails = async (orderId: string) => {
  if (!orderId) {
    console.error("No order ID provided");
    return null;
  }
  
  try {
    // Fetch order with basic details
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .select('*')
      .eq('id', orderId)
      .single();
      
    if (orderError) throw orderError;
    
    // Fetch order items and associated products
    const { data: orderItems, error: itemsError } = await supabase
      .from('order_items')
      .select('*, products(*)')
      .eq('order_id', orderId);
      
    if (itemsError) throw itemsError;
    
    // Fetch customer profile details
    let customerDetails = null;
    if (order.user_id) {
      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', order.user_id)
        .single();
        
      if (!profileError) {
        customerDetails = profile;
      }
    }
    
    // Fetch delivery address if available
    let addressDetails = null;
    if (order.delivery_address_id) {
      const { data: address, error: addressError } = await supabase
        .from('user_addresses')
        .select('*')
        .eq('id', order.delivery_address_id)
        .single();
        
      if (!addressError) {
        addressDetails = address;
      }
    }
    
    // Return complete order details
    return {
      ...order,
      order_items: orderItems,
      customer: customerDetails,
      delivery_address: addressDetails
    };
    
  } catch (error) {
    console.error("Error fetching order details:", error);
    return null;
  }
};

// Helper function to fetch all products and categories in a single request
export const fetchAllMenuData = async () => {
  console.log("Fetching all menu data in a single request");
  
  try {
    // Fetch all categories first
    const { data: categories, error: categoriesError } = await supabase
      .from('categories')
      .select('*')
      .order('display_order', { ascending: true });
    
    if (categoriesError) {
      console.error("Error fetching categories:", categoriesError);
      return [];
    }
    
    // Fetch all products in a single request
    const { data: products, error: productsError } = await supabase
      .from('products')
      .select('*')
      .order('name');
    
    if (productsError) {
      console.error("Error fetching all products:", productsError);
      return [];
    }
    
    // Group products by category
    const menuData = categories.map(category => {
      const categoryProducts = products.filter(product => product.category_id === category.id);
      
      // Transform products to menu items
      const menuItems = categoryProducts.map(product => ({
        id: product.id,
        name: product.name,
        description: product.description,
        price: product.price,
        imageUrl: product.image_url || "/placeholder.svg",
        category: product.category_id as SushiCategory,
        isVegetarian: product.is_vegetarian || false,
        isSpicy: product.is_spicy || false,
        isNew: product.is_new || false,
        isBestSeller: product.is_best_seller || false,
        allergens: product.allergens,
        pieces: product.pieces
      }));
      
      return {
        id: category.id as SushiCategory, // Cast l'ID de la catÃ©gorie en SushiCategory
        name: category.name,
        description: category.description,
        items: menuItems
      };
    });
    
    console.log(`Loaded ${categories.length} categories and ${products.length} total products in a single request`);
    return menuData;
  } catch (error) {
    console.error("Error fetching all menu data:", error);
    return [];
  }
};

// Helper function to fetch products by category
export const fetchProductsByCategory = async (categoryId: string) => {
  console.log(`Fetching products for category: ${categoryId}`);
  const { data, error } = await supabase
    .from('products')
    .select('*')
    .eq('category_id', categoryId)
    .order('name');
  
  if (error) {
    console.error("Error fetching products:", error);
    return [];
  }
  
  console.log(`Found ${data?.length || 0} products for category ${categoryId}`);
  return data || [];
};

// Helper function to fetch all categories
export const fetchCategories = async () => {
  console.log("Fetching all categories");
  const { data, error } = await supabase
    .from('categories')
    .select('*')
    .order('display_order', { ascending: true });
  
  if (error) {
    console.error("Error fetching categories:", error);
    return [];
  }
  
  console.log(`Found ${data?.length || 0} categories`);
  return data || [];
};

// Helper function to fetch all products
export const fetchAllProducts = async () => {
  console.log("Fetching all products");
  const { data, error } = await supabase
    .from('products')
    .select('*, categories(name)')
    .order('name');
  
  if (error) {
    console.error("Error fetching products:", error);
    return [];
  }
  
  console.log(`Found ${data?.length || 0} total products`);
  return data || [];
};

// Helper function to insert a new category
export const insertCategory = async (category: {
  id: string;
  name: string;
  description?: string | null;
  display_order: number;
}) => {
  console.log(`Inserting category: ${category.name}`);
  const { data, error } = await supabase
    .from('categories')
    .insert(category)
    .select('*')
    .single();
    
  if (error) {
    console.error("Error inserting category:", error);
    throw error;
  }
  
  console.log(`Successfully inserted category: ${category.name}`);
  return data;
};

// Helper function to insert a new product
export const insertProduct = async (product: {
  name: string;
  description?: string | null;
  price: number;
  category_id: string;
  image_url?: string | null;
  is_vegetarian?: boolean | null;
  is_spicy?: boolean | null;
  is_new?: boolean | null;
  is_best_seller?: boolean | null;
  allergens?: string[] | null;
  pieces?: number | null;
}) => {
  console.log(`Inserting product: ${product.name} in category ${product.category_id}`);
  const { data, error } = await supabase
    .from('products')
    .insert(product)
    .select('*')
    .single();
    
  if (error) {
    console.error("Error inserting product:", error.message);
    console.error("Product details:", product);
    throw error;
  }
  
  console.log(`Successfully inserted product: ${product.name}`);
  return data;
};

// Helper function to check if a product with the same name exists in a category
export const productExistsInCategory = async (name: string, categoryId: string) => {
  console.log(`Checking if product ${name} exists in category ${categoryId}`);
  const { data, error } = await supabase
    .from('products')
    .select('id')
    .eq('name', name)
    .eq('category_id', categoryId);
  
  if (error) {
    console.error("Error checking product existence:", error);
    return false;
  }
  
  const exists = data && data.length > 0;
  console.log(`Product ${name} in category ${categoryId} exists: ${exists}`);
  return exists;
};

// Helper function to update a product
export const updateProduct = async (productId: string, productData: any) => {
  console.log(`Updating product with ID: ${productId}`);
  const { data, error } = await supabase
    .from('products')
    .update(productData)
    .eq('id', productId)
    .select('*')
    .single();
    
  if (error) {
    console.error("Error updating product:", error);
    throw error;
  }
  
  console.log(`Successfully updated product: ${productData.name}`);
  return data;
};

// Helper function to delete a product
export const deleteProduct = async (productId: string) => {
  console.log(`Deleting product with ID: ${productId}`);
  try {
    // Simple delete operation without trying to count in RETURNING
    const { error } = await supabase
      .from('products')
      .delete()
      .eq('id', productId);
      
    if (error) {
      console.error("Error deleting product:", error);
      throw error;
    }
    
    console.log(`Successfully deleted product with ID: ${productId}`);
    return true;
  } catch (error) {
    console.error("Error in deleteProduct function:", error);
    return false;
  }
};

// Helper function to update a category
export const updateCategory = async (categoryId: string, categoryData: any) => {
  console.log(`Updating category with ID: ${categoryId}`);
  const { data, error } = await supabase
    .from('categories')
    .update(categoryData)
    .eq('id', categoryId)
    .select('*')
    .single();
    
  if (error) {
    console.error("Error updating category:", error);
    throw error;
  }
  
  console.log(`Successfully updated category: ${categoryData.name}`);
  return data;
};

// Helper function to delete a category
export const deleteCategory = async (categoryId: string) => {
  console.log(`Deleting category with ID: ${categoryId}`);
  const { error } = await supabase
    .from('categories')
    .delete()
    .eq('id', categoryId);
    
  if (error) {
    console.error("Error deleting category:", error);
    throw error;
  }
  
  console.log(`Successfully deleted category with ID: ${categoryId}`);
  return true;
};

// Helper function to reorder categories
export const reorderCategories = async (categories: { id: string, display_order: number }[]) => {
  console.log(`Reordering ${categories.length} categories`);
  
  // Create a custom transaction function for updating multiple rows
  const updates = categories.map(cat => {
    return supabase
      .from('categories')
      .update({ display_order: cat.display_order })
      .eq('id', cat.id);
  });
  
  try {
    // Execute all updates in parallel
    await Promise.all(updates);
    console.log("Successfully reordered categories");
    return true;
  } catch (error) {
    console.error("Error reordering categories:", error);
    throw error;
  }
};
